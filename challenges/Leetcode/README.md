# Mi Plan de PrÃ¡ctica de LeetCode para Principiantes

Â¡Bienvenido/a a mi repositorio de prÃ¡ctica de LeetCode! Este espacio estÃ¡ dedicado a documentar mi viaje en la resoluciÃ³n de problemas de algoritmos y estructuras de datos, comenzando con los fundamentos.

El objetivo principal es construir una base sÃ³lida, mejorar mis habilidades de resoluciÃ³n de problemas y crear un registro tangible de mi progreso. Este plan se centra en problemas de nivel "FÃ¡cil" con `Arrays`.

---

## ğŸš€ El Plan de Estudio (2 Semanas)

### **Semana 1 â€” Calentando motores**
**Objetivo:** Familiarizarme con operaciones bÃ¡sicas, bucles y manipulaciÃ³n de arrays simples.

| DÃ­a | Problema | Enlace |
| --- | ------------------------------------------ | ---------------------------------------------------------------------------------- |
| 1 | **Two Sum** | [ğŸ”— Link](https://leetcode.com/problems/two-sum/) |
| 2 | **Build Array from Permutation** | [ğŸ”— Link](https://leetcode.com/problems/build-array-from-permutation/) |
| 3 | **Concatenation of Array** | [ğŸ”— Link](https://leetcode.com/problems/concatenation-of-array/) |
| 4 | **Running Sum of 1d Array** | [ğŸ”— Link](https://leetcode.com/problems/running-sum-of-1d-array/) |
| 5 | **Shuffle the Array** | [ğŸ”— Link](https://leetcode.com/problems/shuffle-the-array/) |
| 6 | **Kids With the Greatest Number of Candies** | [ğŸ”— Link](https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/) |
| 7 | **Richest Customer Wealth** | [ğŸ”— Link](https://leetcode.com/problems/richest-customer-wealth/) |

### **Semana 2 â€” Un poco mÃ¡s de juego**
**Objetivo:** Introducir recorridos dobles, arrays 2D y un poco de lÃ³gica adicional.

| DÃ­a | Problema | Enlace |
| --- | -------------------------------------------- | ------------------------------------------------------------------------------------ |
| 8 | **Number of Good Pairs** | [ğŸ”— Link](https://leetcode.com/problems/number-of-good-pairs/) |
| 9 | **Defanging an IP Address** | [ğŸ”— Link](https://leetcode.com/problems/defanging-an-ip-address/) |
| 10 | **Count Items Matching a Rule** | [ğŸ”— Link](https://leetcode.com/problems/count-items-matching-a-rule/) |
| 11 | **Smaller Numbers Than Current** | [ğŸ”— Link](https://leetcode.com/problems/smaller-numbers-than-current/) |
| 12 | **Create Target Array in the Given Order** | [ğŸ”— Link](https://leetcode.com/problems/create-target-array-in-the-given-order/) |
| 13 | **Find the Highest Altitude** | [ğŸ”— Link](https://leetcode.com/problems/find-the-highest-altitude/) |
| 14 | **Maximum Number of Words Found in Sentences** | [ğŸ”— Link](https://leetcode.com/problems/maximum-number-of-words-found-in-sentences/) |

---

## ğŸ’¡ Mi FilosofÃ­a de PrÃ¡ctica

1.  **Intentar sin Ayuda:** DedicarÃ© al menos 30-45 minutos a cada problema para intentar resolverlo por mi cuenta antes de buscar pistas o soluciones.
2.  **Aprender de Otros:** DespuÃ©s de enviar mi soluciÃ³n (o si me atasco), revisarÃ© la secciÃ³n de soluciones para entender enfoques mÃ¡s eficientes o diferentes.
3.  **Analizar la Complejidad:** Para cada soluciÃ³n, analizarÃ© y anotarÃ© su complejidad temporal (Big O) y espacial. El objetivo es aprender a escribir cÃ³digo no solo que funcione, sino que sea eficiente.
4.  **Documentar el Aprendizaje:** La columna de "Notas" es crucial. AnotarÃ© el "ajÃ¡" de cada problema: el truco, el patrÃ³n o el error que cometÃ­, para no volver a repetirlo.
5.  **Consistencia sobre Intensidad:** La clave es la constancia. Es mejor resolver un problema al dÃ­a que siete en un solo dÃ­a de la semana.

---

## ğŸ“Š Hoja de Seguimiento

| DÃ­a | Problema | Resuelto âœ… | Link a mi SoluciÃ³n | Tiempo (min) | Complejidad | Nota / Aprendizaje Clave |
| --- | ------------------------------------------ |:----------:| :-------------------: | :----------: | :---------: | -------------------------- |
| 1 | Two Sum | â˜ | [SoluciÃ³n]() | | | Entender la soluciÃ³n O(n) con HashMap es clave. |
| 2 | Build Array from Permutation | â˜ | [SoluciÃ³n]() | | | |
| 3 | Concatenation of Array | â˜ | [SoluciÃ³n]() | | | |
| 4 | Running Sum of 1d Array | â˜ | [SoluciÃ³n]() | | | |
| 5 | Shuffle the Array | â˜ | [SoluciÃ³n]() | | | |
| 6 | Kids With Candies | â˜ | [SoluciÃ³n]() | | | |
| 7 | Richest Customer Wealth | â˜ | [SoluciÃ³n]() | | | |
| 8 | Number of Good Pairs | â˜ | [SoluciÃ³n]() | | | |
| 9 | Defanging an IP Address | â˜ | [SoluciÃ³n]() | | | |
| 10 | Count Items Matching a Rule | â˜ | [SoluciÃ³n]() | | | |
| 11 | Smaller Numbers Than Current | â˜ | [SoluciÃ³n]() | | | |
| 12 | Create Target Array | â˜ | [SoluciÃ³n]() | | | |
| 13 | Find the Highest Altitude | â˜ | [SoluciÃ³n]() | | | |
| 14 | Max Words in Sentences | â˜ | [SoluciÃ³n]() | | | |

---

## ğŸ“‚ Estructura del Repositorio

Para mantener todo organizado, cada problema tendrÃ¡ su propia carpeta, nombrada segÃºn el nÃºmero del dÃ­a y el nombre del problema.

```
/
â”œâ”€â”€ 01-Two-Sum/
â”‚   â””â”€â”€ solution.ts         // O .py, .java, etc.
â”œâ”€â”€ 02-Build-Array-from-Permutation/
â”‚   â””â”€â”€ solution.ts
â””â”€â”€ README.md
```

# Ruta completa y estructurada para pasar de resolver problemas "Easy" a "Medium" en LeetCode de manera efectiva.

El salto de Easy a Medium no se trata de ser "mÃ¡s inteligente", sino de conocer las **herramientas y patrones correctos**. Esta ruta se enfoca en aprender esas herramientas de forma progresiva.

---

### **Fase 1: Reforzar la Base y Dominar las Herramientas Clave ğŸ§ **

Antes de atacar los problemas Medium, asegÃºrate de dominar las estructuras de datos que son el "pan de cada dÃ­a" en este nivel. Para cada una, aprende su funcionamiento, ventajas, desventajas y su complejidad (Big O).

**1. Hash Maps (Diccionarios/Tablas Hash)**
* **Â¿Por quÃ©?** Son la herramienta mÃ¡s importante para optimizar soluciones de fuerza bruta (de $O(n^2)$ a $O(n)$). Son esenciales para contar, agrupar o buscar elementos en tiempo constante $O(1)$.
* **Patrones a dominar:**
    * Buscar un complemento (como en "Two Sum").
    * Contar frecuencias de elementos.
    * Agrupar elementos por una propiedad (como en "Group Anagrams").
* **Problemas Medium de prÃ¡ctica:**
    * `Group Anagrams`
    * `Top K Frequent Elements`
    * `Subarray Sum Equals K`

**2. Two Pointers (Dos Punteros)**
* **Â¿Por quÃ©?** Es una tÃ©cnica increÃ­blemente eficiente para problemas con arrays o strings ordenados, permitiendo soluciones en tiempo lineal $O(n)$.
* **Patrones a dominar:**
    * Punteros opuestos que se mueven hacia el centro (para buscar pares).
    * Punteros que avanzan en la misma direcciÃ³n a distintas velocidades (el patrÃ³n "liebre y tortuga" para detectar ciclos).
* **Problemas Medium de prÃ¡ctica:**
    * `3Sum` (un clÃ¡sico absoluto)
    * `Container With Most Water`
    * `Sort Colors`

**3. Stacks (Pilas)**
* **Â¿Por quÃ©?** Perfectas para problemas que siguen una lÃ³gica **LIFO** (Last-In, First-Out), como el manejo de parÃ©ntesis, operaciones de "deshacer" o la evaluaciÃ³n de expresiones.
* **Patrones a dominar:**
    * ParÃ©ntesis o etiquetas balanceadas.
    * Encontrar el "siguiente elemento mayor" (Monotonic Stack).
* **Problemas Medium de prÃ¡ctica:**
    * `Daily Temperatures`
    * `Min Stack`
    * `Validate Stack Sequences`

---

### **Fase 2: Aprender Patrones AlgorÃ­tmicos Fundamentales ğŸ› ï¸**

Con las estructuras de datos dominadas, el siguiente paso es reconocer patrones de algoritmos que se repiten constantemente en problemas de nivel Medio.

**1. Sliding Window (Ventana Deslizante)**
* **Â¿Por quÃ©?** Es la tÃ©cnica principal para resolver problemas sobre "subarrays" o "substrings" que deben cumplir una condiciÃ³n (ej. el mÃ¡s largo, el mÃ¡s corto, etc.). Evita los ineficientes bucles anidados.
* **Patrones a dominar:**
    * Ventana de tamaÃ±o fijo.
    * Ventana de tamaÃ±o variable que se expande y contrae.
* **Problemas Medium de prÃ¡ctica:**
    * `Longest Substring Without Repeating Characters`
    * `Minimum Size Subarray Sum`
    * `Permutation in String`

**2. Binary Search (BÃºsqueda Binaria)**
* **Â¿Por quÃ©?** En nivel Medium, no solo se usa para buscar en arrays ordenados. Se aplica a cualquier problema donde puedas "adivinar" una respuesta y verificar si es demasiado alta o demasiado baja (lo que se conoce como "bÃºsqueda binaria sobre la respuesta").
* **Patrones a dominar:**
    * BÃºsqueda en un array rotado.
    * Encontrar el mÃ­nimo o mÃ¡ximo que satisface una condiciÃ³n.
* **Problemas Medium de prÃ¡ctica:**
    * `Search in Rotated Sorted Array`
    * `Find Minimum in Rotated Sorted Array`
    * `Koko Eating Bananas`

**3. Breadth-First Search (BFS) y Depth-First Search (DFS)**
* **Â¿Por quÃ©?** Son los algoritmos fundamentales para recorrer estructuras como **Ã¡rboles y grafos**. BFS es ideal para encontrar el camino mÃ¡s corto, mientras que DFS es Ãºtil para explorar todas las posibilidades.
* **Patrones a dominar:**
    * **BFS con una Cola (Queue):** Para recorridos por niveles y caminos mÃ­nimos.
    * **DFS con RecursiÃ³n (o un Stack):** Para explorar un camino hasta el final.
* **Problemas Medium de prÃ¡ctica:**
    * `Number of Islands` (el problema mÃ¡s icÃ³nico de este patrÃ³n)
    * `Rotting Oranges` (un BFS clÃ¡sico)
    * `Binary Tree Level Order Traversal` (BFS en Ã¡rboles)
    * `Validate Binary Search Tree` (DFS en Ã¡rboles)

---

### **Fase 3: TransiciÃ³n y ConsolidaciÃ³n ğŸ¯**

Ahora estÃ¡s listo para mezclar todo y enfrentarte a problemas Medium de forma mÃ¡s general.

**Plan de AcciÃ³n:**
1.  **EnfÃ³cate en un patrÃ³n por semana:** Dedica una semana a problemas de "Two Pointers", la siguiente a "Sliding Window", y asÃ­ sucesivamente. Esto te ayuda a interiorizar el patrÃ³n.
2.  **Usa las listas de LeetCode:** Explora las listas como el **"Top Interview Questions"** (marcando solo Medium) o el **"LeetCode 75"**. Son colecciones de problemas de alta calidad que cubren los patrones mÃ¡s importantes.
3.  **No mires la soluciÃ³n demasiado pronto:** Lucha con el problema por lo menos 45-60 minutos. Intenta dibujar el problema, probar con ejemplos pequeÃ±os y verbalizar tu lÃ³gica. El verdadero aprendizaje ocurre durante este esfuerzo.
4.  **Estudia la soluciÃ³n, no la copies:** Cuando veas una soluciÃ³n, tu objetivo no es memorizar el cÃ³digo, sino entender el **patrÃ³n**. PregÃºntate: "Â¿Por quÃ© un Hash Map fue la mejor opciÃ³n aquÃ­? Â¿QuÃ© seÃ±al me indicaba que debÃ­a usar una Sliding Window?".
5.  **RepeticiÃ³n Espaciada:** DespuÃ©s de resolver un problema, vuelve a intentarlo una semana despuÃ©s sin ver tu cÃ³digo anterior. Si puedes resolverlo rÃ¡pidamente, has internalizado el patrÃ³n.

Siguiendo esta ruta, no solo resolverÃ¡s problemas Medium, sino que construirÃ¡s una comprensiÃ³n profunda de los fundamentos que te servirÃ¡ para cualquier desafÃ­o de programaciÃ³n. Â¡Mucho Ã©xito!